<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Multi-Head Attention</title>
    <style>
        :root {
            --bg: #0f172a;
            --text: #e2e8f0;
            --h1-color: #ec4899; /* Pink */
            --h2-color: #3b82f6; /* Blue */
            --panel: #1e293b;
            --border: #334155;
        }
        body { 
            font-family: 'Segoe UI', sans-serif; 
            background: var(--bg); 
            color: var(--text); 
            margin: 0; 
            padding: 0; 
            overflow-x: hidden; /* Prevent horizontal scroll only */
            min-height: 100vh;
        }
        
        .container { 
            max-width: 1000px; 
            margin: 0 auto; 
            padding-bottom: 50px;
            position: relative;
        }
        
        /* Sticky Controls */
        .controls { 
            background: rgba(30, 41, 59, 0.95); 
            padding: 20px; 
            position: sticky; 
            top: 0; 
            z-index: 50; 
            border-bottom: 1px solid var(--border);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .input-row { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px; }
        
        input { 
            background: #0f172a; 
            border: 1px solid var(--border); 
            color: white; 
            padding: 10px; 
            flex-grow: 1; 
            min-width: 200px; 
            border-radius: 6px; 
            font-size: 1rem;
        }
        
        button { 
            padding: 10px 20px; 
            border-radius: 6px; 
            cursor: pointer; 
            border: none; 
            font-weight: bold; 
            transition: all 0.2s;
        }
        
        /* Button Styles */
        .btn-random { background: #475569; color: white; }
        .btn-random:hover { background: #64748b; }
        
        .btn-h1 { background: transparent; color: var(--h1-color); border: 1px solid var(--h1-color); }
        .btn-h2 { background: transparent; color: var(--h2-color); border: 1px solid var(--h2-color); }
        
        .btn-h1.active { background: var(--h1-color); color: white; }
        .btn-h2.active { background: var(--h2-color); color: white; }

        /* Visualization Area */
        .viz-wrapper { 
            position: relative; 
            margin-top: 40px; 
            padding: 0 20px;
        }
        
        .columns-container {
            display: flex; 
            justify-content: space-between; 
            position: relative; 
            z-index: 2;
        }
        
        .column { 
            display: flex; 
            flex-direction: column; 
            gap: 30px; 
            width: 150px;
        }
        
        .column-label { 
            text-align: center; 
            font-size: 0.9rem; 
            text-transform: uppercase; 
            letter-spacing: 2px; 
            color: #94a3b8; 
            margin-bottom: 20px; 
            font-weight: bold;
        }
        
        .token {
            padding: 12px; 
            background: var(--panel); 
            border: 1px solid var(--border);
            border-radius: 8px; 
            cursor: pointer; 
            text-align: center;
            user-select: none;
            position: relative;
            transition: transform 0.2s, background 0.2s;
        }
        
        .token:hover { background: #334155; transform: scale(1.05); }
        .token.selected { background: #f8fafc; color: #0f172a; font-weight: bold; border-color: white; transform: scale(1.1); box-shadow: 0 0 20px rgba(255,255,255,0.2); }

        /* SVG Canvas */
        #connections-svg { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 1; 
            pointer-events: none; 
            /* Ensure it sits behind tokens */
        }
        
        path { fill: none; mix-blend-mode: screen; transition: stroke-opacity 0.2s; }

        /* Tooltip */
        #tooltip {
            position: fixed; /* Fixed relative to viewport */
            background: rgba(15, 23, 42, 0.95); 
            padding: 12px; 
            border-radius: 6px;
            font-size: 0.85rem; 
            pointer-events: none; 
            display: none; 
            border: 1px solid #475569;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 100;
            width: 200px;
        }
        .bar-bg { width: 100%; background: #334155; height: 6px; border-radius: 3px; margin-top: 6px; overflow: hidden;}
        .bar-fill { height: 100%; transition: width 0.2s; }

    </style>
</head>
<body>

<div class="container">
    <div class="controls">
        <h2 style="margin: 0 0 15px 0;">Multi-Head Attention Visualizer</h2>
        
        <div class="input-row">
            <input type="text" id="inputText" value="The animal did not cross the street because it was too tired" onkeyup="debounceInit()">
            <button class="btn-random" onclick="init(true)">ðŸŽ² Randomize Weights</button>
        </div>
        
        <div style="display:flex; align-items:center; gap:15px; flex-wrap: wrap;">
            <span style="font-size:0.9em; color:#94a3b8;">Active Heads:</span>
            <button id="btnH1" class="btn-h1 active" onclick="toggleHead(1)">Head 1 (Pink)</button>
            <button id="btnH2" class="btn-h2 active" onclick="toggleHead(2)">Head 2 (Blue)</button>
        </div>
        
        <div style="margin-top:10px; font-size: 0.85em; color: #94a3b8;">
            <strong>Instructions:</strong> Hover over a word on the <strong>LEFT</strong> (Query) to see who it attends to on the <strong>RIGHT</strong> (Key).
        </div>
    </div>

    <div class="viz-wrapper">
        <svg id="connections-svg"></svg>
        
        <div class="columns-container">
            <div class="column" id="col-query">
                <div class="column-label">Query (Source)</div>
                </div>

            <div class="column" id="col-key">
                <div class="column-label">Key (Target)</div>
                </div>
        </div>
    </div>
</div>

<div id="tooltip"></div>

<script>
    // --- State ---
    let words = [];
    let attentionScores = { h1: [], h2: [] };
    let activeIndex = null;
    let showH1 = true;
    let showH2 = true;

    // --- Logic ---
    function generateRandomScores(N) {
        // Create interesting attention patterns
        const scores = [];
        for (let i = 0; i < N; i++) {
            // Raw logits
            let row = Array(N).fill(0).map(() => Math.random() * 2); 
            
            // Add Structure (so it's not pure noise)
            row[i] += 3.0; // Bias to self
            if (i > 0) row[i-1] += 2.0; // Bias to previous
            
            // Softmax
            const exps = row.map(Math.exp);
            const sum = exps.reduce((a, b) => a + b, 0);
            scores.push(exps.map(e => e / sum));
        }
        return scores;
    }

    function init(forceRandom = false) {
        const text = document.getElementById('inputText').value;
        // Split by space, preserve non-empty
        words = text.trim().split(/\s+/).filter(w => w.length > 0);
        
        // Setup DOM
        const qCol = document.getElementById('col-query');
        const kCol = document.getElementById('col-key');
        
        // Clear previous
        qCol.querySelectorAll('.token').forEach(e => e.remove());
        kCol.querySelectorAll('.token').forEach(e => e.remove());

        words.forEach((w, i) => {
            qCol.appendChild(createToken(w, i, true));
            kCol.appendChild(createToken(w, i, false));
        });

        // Generate Scores
        if (forceRandom || attentionScores.h1.length !== words.length) {
            attentionScores.h1 = generateRandomScores(words.length);
            // Make H2 different (reverse bias for fun)
            const h2 = generateRandomScores(words.length);
            // Shuffle h2 rows slightly to make it distinct from h1
            attentionScores.h2 = h2.map(row => {
                const newRow = [...row];
                const last = newRow.pop();
                newRow.unshift(last);
                return newRow;
            });
        }

        // Resize SVG to match content
        requestAnimationFrame(updateSvgSize);
    }

    function createToken(word, index, isQuery) {
        const div = document.createElement('div');
        div.className = 'token';
        div.innerText = word;
        div.dataset.index = index;
        
        if (isQuery) {
            div.onmouseenter = () => {
                activeIndex = index;
                renderLines();
                div.classList.add('selected');
            };
            div.onmouseleave = () => {
                div.classList.remove('selected');
            };
        }
        return div;
    }

    function updateSvgSize() {
        const wrapper = document.querySelector('.columns-container');
        const svg = document.getElementById('connections-svg');
        svg.style.height = wrapper.scrollHeight + 'px';
    }

    function renderLines() {
        const svg = document.getElementById('connections-svg');
        svg.innerHTML = ''; // Clear lines
        
        if (activeIndex === null) return;

        const qTokens = document.querySelectorAll('#col-query .token');
        const kTokens = document.querySelectorAll('#col-key .token');
        
        if (!qTokens[activeIndex]) return;

        const startRect = getRelativeRect(qTokens[activeIndex]);
        const startX = startRect.right; 
        const startY = startRect.centerY;

        kTokens.forEach((kTok, targetIdx) => {
            const endRect = getRelativeRect(kTok);
            const endX = endRect.left;
            const endY = endRect.centerY;

            // Draw Head 1 (Pink)
            if (showH1) {
                const score = attentionScores.h1[activeIndex][targetIdx];
                if (score > 0.02) { // Threshold
                   drawBezier(svg, startX, startY, endX, endY, score, '#ec4899', 'Head 1', targetIdx);
                }
            }

            // Draw Head 2 (Blue)
            if (showH2) {
                const score = attentionScores.h2[activeIndex][targetIdx];
                if (score > 0.02) {
                    // Slight vertical offset for Head 2 so lines don't perfectly overlap
                   drawBezier(svg, startX, startY + 4, endX, endY + 4, score, '#3b82f6', 'Head 2', targetIdx);
                }
            }
        });
    }

    function getRelativeRect(element) {
        const wrapper = document.querySelector('.viz-wrapper');
        const rect = element.getBoundingClientRect();
        const wrapperRect = wrapper.getBoundingClientRect();
        
        return {
            left: rect.left - wrapperRect.left,
            right: (rect.left - wrapperRect.left) + rect.width,
            top: rect.top - wrapperRect.top,
            centerY: (rect.top - wrapperRect.top) + (rect.height / 2)
        };
    }

    function drawBezier(svg, x1, y1, x2, y2, score, color, headName, targetIdx) {
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        
        // Control points for smooth S-curve
        const c1x = x1 + (x2 - x1) / 2;
        const c1y = y1;
        const c2x = x2 - (x2 - x1) / 2;
        const c2y = y2;
        
        const d = `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
        
        path.setAttribute("d", d);
        path.setAttribute("stroke", color);
        // Thickness based on score (min 1px, max 8px)
        path.setAttribute("stroke-width", Math.max(1, score * 10)); 
        // Opacity based on score
        path.setAttribute("stroke-opacity", Math.max(0.1, score));

        // Tooltip Interaction
        path.onmousemove = (e) => showTooltip(e, headName, score, words[targetIdx], color);
        path.onmouseleave = hideTooltip;

        svg.appendChild(path);
    }

    // --- Tooltip & UI Helpers ---
    const tooltip = document.getElementById('tooltip');

    function showTooltip(e, head, score, word, color) {
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY + 15) + 'px';
        
        tooltip.innerHTML = `
            <div style="color:${color}; font-weight:bold">${head}</div>
            <div>Attends to: <strong>"${word}"</strong></div>
            <div style="font-size:0.8em; margin-top:4px">Attention Score: ${(score*100).toFixed(1)}%</div>
            <div class="bar-bg"><div class="bar-fill" style="width:${score*100}%; background:${color}"></div></div>
        `;
    }

    function hideTooltip() {
        tooltip.style.display = 'none';
    }

    function toggleHead(h) {
        if (h === 1) {
            showH1 = !showH1;
            document.getElementById('btnH1').classList.toggle('active');
        } else {
            showH2 = !showH2;
            document.getElementById('btnH2').classList.toggle('active');
        }
        renderLines();
    }

    let timeout;
    function debounceInit() {
        clearTimeout(timeout);
        timeout = setTimeout(() => init(true), 500);
    }

    // Run on load
    window.onload = () => {
        init(true);
        // Highlight middle word to show initial state
        setTimeout(() => {
            const tokens = document.querySelectorAll('#col-query .token');
            if(tokens.length > 2) {
                activeIndex = Math.floor(tokens.length / 2);
                tokens[activeIndex].classList.add('selected');
                renderLines();
            }
        }, 200);
    };

    // Handle window resize
    window.onresize = () => {
        updateSvgSize();
        renderLines();
    };

</script>
</body>
</html>
