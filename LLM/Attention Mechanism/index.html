<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep Dive: Multi-Head Attention</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <style>
        :root {
            --bg: #0f172a; --card: #1e293b; --text: #f1f5f9;
            --h1-color: #f472b6; /* Pink for Head 1 */
            --h2-color: #38bdf8; /* Blue for Head 2 */
            --mix-color: #a78bfa; /* Purple for Output */
        }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        
        /* Controls */
        .controls { background: var(--card); padding: 20px; border-radius: 8px; margin-bottom: 20px; display: flex; gap: 20px; align-items: center; flex-wrap: wrap;}
        input { background: #334155; border: 1px solid #475569; color: white; padding: 8px; width: 300px; border-radius: 4px; }
        button { background: var(--mix-color); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold; }
        button:hover { opacity: 0.9; }

        /* Grid Layout */
        .pipeline { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .full-width { grid-column: span 2; }
        
        .panel { background: var(--card); padding: 15px; border-radius: 8px; border: 1px solid #334155; position: relative; }
        .panel h3 { margin-top: 0; font-size: 1rem; opacity: 0.9; }
        
        /* Head Branding */
        .head-1 { border-top: 4px solid var(--h1-color); }
        .head-2 { border-top: 4px solid var(--h2-color); }
        .head-out { border-top: 4px solid var(--mix-color); }

        /* Matrix Visualization */
        .matrix-container { display: flex; flex-direction: column; gap: 2px; margin-top: 10px; overflow-x: auto; }
        .row { display: flex; gap: 2px; align-items: center; }
        .label { width: 60px; font-size: 12px; text-align: right; margin-right: 8px; opacity: 0.7; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        .cell { 
            width: 30px; height: 30px; 
            display: flex; align-items: center; justify-content: center; 
            font-size: 10px; color: transparent; 
            border-radius: 2px; cursor: pointer; transition: transform 0.1s;
        }
        .cell:hover { transform: scale(1.2); z-index: 10; border: 1px solid white; color: white; font-weight: bold; text-shadow: 0 1px 2px black; }
        
        /* Inspector */
        #inspector {
            position: fixed; bottom: 20px; right: 20px; width: 300px;
            background: rgba(15, 23, 42, 0.95); border: 1px solid #475569;
            padding: 15px; border-radius: 8px; backdrop-filter: blur(5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); display: none; font-size: 0.9rem;
        }
        .math { font-family: monospace; background: #000; padding: 8px; border-radius: 4px; margin: 5px 0; color: #86efac; }

        /* Legend */
        .legend { font-size: 0.8rem; opacity: 0.7; margin-top: 5px; }
    </style>
</head>
<body>

<div class="container">
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <h1>Multi-Head Attention Visualizer</h1>
        <div class="legend">
            <span style="color:var(--h1-color)">■ Head 1</span> &nbsp; 
            <span style="color:var(--h2-color)">■ Head 2</span>
        </div>
    </div>

    <div class="controls">
        <div>
            <label>Input Sentence:</label><br>
            <input type="text" id="input-text" value="The animal did not cross it" onkeyup="debounceRun()">
        </div>
        <button onclick="randomizeWeights()">Re-Roll Random Weights</button>
        <div style="font-size: 0.85rem; max-width: 500px;">
            <strong>Config:</strong> 2 Heads. $d_{model}=8$. Head size ($d_k$)=$4$.<br>
            Hover over any cell to see the raw value.
        </div>
    </div>

    <div class="pipeline">
        <div class="panel full-width">
            <h3>1. Input Embeddings ($X$)</h3>
            <div class="legend">Shape: [Seq Length, 8]</div>
            <div id="viz-embeddings" class="matrix-container"></div>
        </div>

        <div class="panel head-1">
            <h3>Head 1: Attention Map</h3>
            <div class="legend">Does "it" attend to "animal"?</div>
            <div id="viz-h1-att" class="matrix-container"></div>
            <div style="margin-top:15px">
                <h3>Head 1: Output ($Z_1$)</h3>
                <div class="legend">Shape: [Seq, 4]</div>
                <div id="viz-h1-out" class="matrix-container"></div>
            </div>
        </div>

        <div class="panel head-2">
            <h3>Head 2: Attention Map</h3>
            <div class="legend">Does "it" attend to "cross"?</div>
            <div id="viz-h2-att" class="matrix-container"></div>
            <div style="margin-top:15px">
                <h3>Head 2: Output ($Z_2$)</h3>
                <div class="legend">Shape: [Seq, 4]</div>
                <div id="viz-h2-out" class="matrix-container"></div>
            </div>
        </div>

        <div class="panel full-width head-out">
            <h3>4. Concatenation & Linear Projection ($W^O$)</h3>
            <p style="font-size:0.9rem">We stack Head 1 and Head 2 side-by-side ($4+4=8$) and multiply by $W^O$ to mix the information.</p>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:20px;">
                <div>
                    <h4>Concatenated Heads</h4>
                    <div id="viz-concat" class="matrix-container"></div>
                </div>
                <div>
                    <h4>Final Output ($Z$)</h4>
                    <div id="viz-final" class="matrix-container"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="inspector">
    <strong>Inspector</strong><br>
    <span id="insp-desc">Hover over a cell.</span>
    <div id="insp-val" class="math"></div>
</div>

<script>
    // --- Config ---
    const D_MODEL = 8;
    const N_HEADS = 2;
    const D_K = D_MODEL / N_HEADS; // 4
    
    // Global State
    let WQ = [], WK = [], WV = [], WO;
    let embeddings = [];
    let words = [];

    // --- Core Logic ---

    function initWeights() {
        // Initialize weights for each head
        WQ = []; WK = []; WV = [];
        for(let h=0; h<N_HEADS; h++) {
            WQ.push(math.random([D_MODEL, D_K], -1, 1));
            WK.push(math.random([D_MODEL, D_K], -1, 1));
            WV.push(math.random([D_MODEL, D_K], -1, 1));
        }
        // Final Output Projection Matrix
        WO = math.random([D_MODEL, D_MODEL], -1, 1);
        runPipeline();
    }

    function getEmbedding(word) {
        // Deterministic "random" embedding based on word content
        let seed = 0;
        for (let i = 0; i < word.length; i++) seed += word.charCodeAt(i);
        const rng = (x) => {
            const z = Math.sin(seed + x * 133) * 43758.5453;
            return z - Math.floor(z);
        };
        return Array.from({length: D_MODEL}, (_, i) => (rng(i) * 2 - 1));
    }

    function softmax(arr) {
        const exps = arr.map(Math.exp);
        const sum = exps.reduce((a, b) => a + b, 0);
        return exps.map(e => e / sum);
    }

    function runPipeline() {
        const text = document.getElementById('input-text').value;
        words = text.trim().split(/\s+/);
        if(words.length === 0) return;

        // 1. Embeddings
        const X = words.map(getEmbedding);
        renderMatrix('viz-embeddings', X, words);

        let headOutputs = []; // To store output of each head

        // 2. Process Heads
        for(let h=0; h<N_HEADS; h++) {
            // Linear Projections
            const Q = math.multiply(X, WQ[h]); // [Seq, 4]
            const K = math.multiply(X, WK[h]); // [Seq, 4]
            const V = math.multiply(X, WV[h]); // [Seq, 4]

            // Scaled Dot-Product Attention
            // Scores = Q @ K.T / sqrt(d_k)
            const scoresRaw = math.multiply(Q, math.transpose(K));
            const scale = Math.sqrt(D_K);
            const scoresScaled = math.divide(scoresRaw, scale);

            // Softmax row-wise
            const attnWeights = scoresScaled.map(row => softmax(row));

            // Weighted Sum (Z_head)
            const Z_head = math.multiply(attnWeights, V);
            headOutputs.push(Z_head);

            // Viz
            renderAttention(`viz-h${h+1}-att`, attnWeights, words, h);
            renderMatrix(`viz-h${h+1}-out`, Z_head, words);
        }

        // 3. Concatenation
        // Stack head outputs horizontally. Row i of Head 1 + Row i of Head 2
        const concatZ = X.map((_, i) => {
            return [...headOutputs[0][i], ...headOutputs[1][i]];
        });
        renderMatrix('viz-concat', concatZ, words);

        // 4. Final Projection
        const finalZ = math.multiply(concatZ, WO);
        renderMatrix('viz-final', finalZ, words);
    }

    // --- Visualization Helpers ---

    function getColor(val, isProb = false) {
        if(isProb) {
            // For attention (0 to 1), use blue scale
            const g = Math.floor(255 * (1-val));
            return `rgb(${g}, ${g}, 255)`;
        }
        // For vectors (-1 to 1), use Heatmap (Red=Neg, Green=Pos)
        const intensity = Math.min(Math.abs(val), 1);
        if (val < 0) return `rgba(248, 113, 113, ${intensity})`; // Red
        return `rgba(74, 222, 128, ${intensity})`; // Green
    }

    function renderMatrix(id, data, labels) {
        const div = document.getElementById(id);
        div.innerHTML = '';
        
        data.forEach((row, r) => {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'row';
            
            const lab = document.createElement('div');
            lab.className = 'label';
            lab.innerText = labels[r];
            rowDiv.appendChild(lab);

            row.forEach((val, c) => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.style.backgroundColor = getColor(val);
                cell.innerText = val.toFixed(1);
                
                // Inspect
                cell.onmouseenter = () => showInspect(val.toFixed(3), `Vector value at [${r},${c}]`);
                cell.onmouseleave = hideInspect;
                
                rowDiv.appendChild(cell);
            });
            div.appendChild(rowDiv);
        });
    }

    function renderAttention(id, data, labels, headIndex) {
        const div = document.getElementById(id);
        div.innerHTML = '';
        
        // Header (Columns are Key words)
        const header = document.createElement('div');
        header.className = 'row';
        header.innerHTML = '<div class="label"></div>';
        labels.forEach(w => {
            const hCell = document.createElement('div');
            hCell.style.width = '30px'; 
            hCell.style.fontSize='9px'; 
            hCell.style.textAlign='center';
            hCell.style.writingMode='vertical-rl';
            hCell.innerText = w.substring(0,5);
            header.appendChild(hCell);
        });
        div.appendChild(header);

        data.forEach((row, r) => {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'row';
            
            const lab = document.createElement('div');
            lab.className = 'label';
            lab.innerText = labels[r]; // Query word
            rowDiv.appendChild(lab);

            row.forEach((val, c) => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.style.backgroundColor = getColor(val, true);
                cell.style.color = val > 0.5 ? 'white' : 'black';
                cell.innerText = val.toFixed(1);
                
                // Inspect
                cell.onmouseenter = () => showInspect(
                    (val*100).toFixed(1) + '%', 
                    `Head ${headIndex+1}: "${labels[r]}" attending to "${labels[c]}"`
                );
                cell.onmouseleave = hideInspect;
                
                rowDiv.appendChild(cell);
            });
            div.appendChild(rowDiv);
        });
    }

    function showInspect(val, desc) {
        const ins = document.getElementById('inspector');
        ins.style.display = 'block';
        document.getElementById('insp-val').innerText = val;
        document.getElementById('insp-desc').innerText = desc;
    }

    function hideInspect() {
        document.getElementById('inspector').style.display = 'none';
    }

    let timeout;
    function debounceRun() {
        clearTimeout(timeout);
        timeout = setTimeout(runPipeline, 500);
    }

    function randomizeWeights() {
        initWeights();
    }

    // Start
    initWeights();

</script>
</body>
</html>
