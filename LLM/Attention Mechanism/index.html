<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Multi-Head Attention</title>
    <style>
        :root {
            --bg: #0f172a;
            --text: #e2e8f0;
            --h1-color: #ec4899; /* Pink */
            --h2-color: #3b82f6; /* Blue */
            --panel: #1e293b;
        }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 20px; overflow: hidden; }
        .container { max-width: 1000px; margin: 0 auto; display: flex; flex-direction: column; height: 95vh; }
        
        /* Controls */
        .controls { background: var(--panel); padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); z-index: 10; }
        input { background: #334155; border: 1px solid #475569; color: white; padding: 8px; width: 300px; border-radius: 4px; }
        button { padding: 8px 16px; border-radius: 4px; cursor: pointer; border: none; font-weight: bold; margin-left: 10px; }
        .btn-h1 { background: rgba(236, 72, 153, 0.2); color: var(--h1-color); border: 1px solid var(--h1-color); }
        .btn-h2 { background: rgba(59, 130, 246, 0.2); color: var(--h2-color); border: 1px solid var(--h2-color); }
        .btn-active { background: currentColor; color: #000; }

        /* Visualization Area */
        .viz-area { flex-grow: 1; position: relative; display: flex; justify-content: space-between; padding: 0 50px; }
        
        .column { display: flex; flex-direction: column; justify-content: center; gap: 40px; z-index: 2; }
        .column-label { text-align: center; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 2px; opacity: 0.6; margin-bottom: 20px; }
        
        .token {
            padding: 10px 20px; background: var(--panel); border: 1px solid #475569;
            border-radius: 20px; cursor: pointer; transition: all 0.2s; text-align: center;
            min-width: 80px; user-select: none;
        }
        .token:hover, .token.active { background: #fff; color: #000; transform: scale(1.1); font-weight: bold; box-shadow: 0 0 15px rgba(255,255,255,0.3); }

        /* SVG Canvas */
        #connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        path { fill: none; transition: stroke-opacity 0.3s; mix-blend-mode: screen; }

        /* Tooltip */
        #tooltip {
            position: absolute; background: rgba(0,0,0,0.9); padding: 10px; border-radius: 4px;
            font-size: 0.8rem; pointer-events: none; display: none; border: 1px solid #666;
            max-width: 250px; z-index: 100;
        }
        .bar-container { display: flex; align-items: center; margin-top: 5px; gap: 5px; }
        .bar { height: 6px; border-radius: 3px; }
    </style>
</head>
<body>

<div class="container">
    <div class="controls">
        <h3>Multi-Head Attention: The Connection View</h3>
        <div style="margin-bottom: 10px;">
            <label>Sentence:</label>
            <input type="text" id="inputText" value="The animal didn't cross it" onkeyup="init()">
            <button onclick="randomizeWeights()">ðŸŽ² New Random Weights</button>
        </div>
        <div>
            <strong>Toggle Heads:</strong>
            <button id="btnH1" class="btn-h1 btn-active" onclick="toggleHead(1)">Head 1 (Grammar)</button>
            <button id="btnH2" class="btn-h2 btn-active" onclick="toggleHead(2)">Head 2 (Context)</button>
        </div>
        <div style="margin-top:10px; font-size: 0.9em; opacity: 0.8;">
            Hover over a word on the <strong>Left</strong> to see what it is paying attention to on the <strong>Right</strong>.
        </div>
    </div>

    <div class="viz-area">
        <svg id="connections"></svg>
        
        <div class="column" id="col-query">
            <div class="column-label">Query (Looking For)</div>
            </div>

        <div class="column" id="col-key">
            <div class="column-label">Key (Being Looked At)</div>
            </div>
    </div>
</div>

<div id="tooltip"></div>

<script>
    // --- Configuration ---
    let words = [];
    let attentionScores = { h1: [], h2: [] };
    let activeTokenIndex = null;
    let showH1 = true;
    let showH2 = true;

    // --- Math Logic (Simplified for Visualization) ---
    function randomizeWeights() {
        // We simulate attention scores rather than doing full matrix math 
        // to ensure the visualization is always "interesting" to look at.
        // In a real app, you'd run the dot products here.
        
        const N = words.length;
        attentionScores.h1 = [];
        attentionScores.h2 = [];

        for (let i = 0; i < N; i++) {
            // Head 1: Likes "Diagonal" (Self-Attention) and Previous word
            let row1 = Array(N).fill(0).map(() => Math.random() * 0.1); 
            row1[i] += 2.0; // Strong self-bias
            if(i > 0) row1[i-1] += 1.5; // Previous word bias
            attentionScores.h1.push(softmax(row1));

            // Head 2: Likes "Random" long distance connections (Context)
            let row2 = Array(N).fill(0).map(() => Math.random());
            // Bias towards nouns or specific connections
            if (i === words.length - 1) { // The last word usually looks back
                row2[1] += 3.0; // Force attention to 2nd word
            }
            attentionScores.h2.push(softmax(row2));
        }
        renderLines();
    }

    function softmax(arr) {
        const exps = arr.map(Math.exp);
        const sum = exps.reduce((a, b) => a + b, 0);
        return exps.map(e => e / sum);
    }

    // --- Visualization Logic ---
    function init() {
        const text = document.getElementById('inputText').value;
        words = text.trim().split(/\s+/);
        
        // Render Columns
        const qCol = document.getElementById('col-query');
        const kCol = document.getElementById('col-key');
        qCol.innerHTML = '<div class="column-label">Query (Source)</div>';
        kCol.innerHTML = '<div class="column-label">Key (Target)</div>';

        words.forEach((w, i) => {
            const t1 = createToken(w, i, 'q');
            const t2 = createToken(w, i, 'k');
            qCol.appendChild(t1);
            kCol.appendChild(t2);
        });

        // Generate Data
        randomizeWeights();
    }

    function createToken(word, index, type) {
        const div = document.createElement('div');
        div.className = 'token';
        div.innerText = word;
        div.dataset.index = index;
        
        if (type === 'q') {
            div.onmouseenter = () => {
                activeTokenIndex = index;
                highlightToken(index);
                renderLines();
            };
            // div.onmouseleave = () => {
            //    activeTokenIndex = null;
            //    renderLines();
            // };
        }
        return div;
    }

    function highlightToken(index) {
        document.querySelectorAll('.token').forEach(t => t.classList.remove('active'));
        // Highlight Query
        const qTokens = document.getElementById('col-query').querySelectorAll('.token');
        if(qTokens[index]) qTokens[index].classList.add('active');
    }

    function renderLines() {
        const svg = document.getElementById('connections');
        svg.innerHTML = '';
        if (activeTokenIndex === null) return;

        const qTokens = document.getElementById('col-query').querySelectorAll('.token');
        const kTokens = document.getElementById('col-key').querySelectorAll('.token');
        
        const startElem = qTokens[activeTokenIndex];
        const startRect = startElem.getBoundingClientRect();
        const svgRect = svg.getBoundingClientRect();

        // Calculate Start Point (Right side of Query token)
        const x1 = startRect.right - svgRect.left;
        const y1 = startRect.top + startRect.height/2 - svgRect.top;

        // Draw lines to ALL key tokens
        kTokens.forEach((endElem, targetIndex) => {
            const endRect = endElem.getBoundingClientRect();
            const x2 = endRect.left - svgRect.left;
            const y2 = endRect.top + endRect.height/2 - svgRect.top;

            // Bezier Control Points
            const c1x = x1 + (x2 - x1) / 2;
            const c1y = y1;
            const c2x = x2 - (x2 - x1) / 2;
            const c2y = y2;
            const pathData = `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;

            // Draw Head 1
            if (showH1) {
                const score1 = attentionScores.h1[activeTokenIndex][targetIndex];
                if (score1 > 0.05) { // Threshold to reduce clutter
                    drawPath(svg, pathData, '#ec4899', score1 * 4, score1, targetIndex, 'Head 1');
                }
            }

            // Draw Head 2
            if (showH2) {
                const score2 = attentionScores.h2[activeTokenIndex][targetIndex];
                if (score2 > 0.05) {
                    // Offset slightly so they don't perfectly overlap
                    drawPath(svg, pathData, '#3b82f6', score2 * 4, score2, targetIndex, 'Head 2', 3);
                }
            }
        });
    }

    function drawPath(svg, d, color, width, opacity, targetIdx, headName, offset=0) {
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", d);
        path.setAttribute("stroke", color);
        path.setAttribute("stroke-width", width);
        path.setAttribute("stroke-opacity", opacity);
        if(offset) path.setAttribute("transform", `translate(0, ${offset})`);
        
        path.onmouseenter = (e) => showTooltip(e, headName, opacity, words[targetIdx]);
        path.onmousemove = (e) => showTooltip(e, headName, opacity, words[targetIdx]);
        path.onmouseleave = hideTooltip;
        
        svg.appendChild(path);
    }

    // --- Interactivity ---
    function toggleHead(h) {
        if (h === 1) {
            showH1 = !showH1;
            document.getElementById('btnH1').classList.toggle('btn-active');
        } else {
            showH2 = !showH2;
            document.getElementById('btnH2').classList.toggle('btn-active');
        }
        renderLines();
    }

    // --- Tooltip ---
    const tooltip = document.getElementById('tooltip');
    function showTooltip(e, head, value, word) {
        tooltip.style.display = 'block';
        tooltip.style.left = e.pageX + 10 + 'px';
        tooltip.style.top = e.pageY + 10 + 'px';
        tooltip.innerHTML = `
            <strong>${head}</strong><br>
            Attending to: "<em>${word}</em>"<br>
            Strength: ${(value*100).toFixed(1)}%
            <div class="bar-container">
                <div class="bar" style="width: ${value*100}%; background: ${head === 'Head 1' ? '#ec4899' : '#3b82f6'}"></div>
            </div>
        `;
    }
    function hideTooltip() {
        tooltip.style.display = 'none';
    }

    // Start
    init();
    // Auto-select the last word to show "it" resolution immediately
    setTimeout(() => {
        activeTokenIndex = words.length - 1;
        highlightToken(activeTokenIndex);
        renderLines();
    }, 100);

</script>
</body>
</html>
