<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Lifecycle of a SQL Query</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=JetBrains+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Slate 900 */
            color: #e2e8f0; /* Slate 200 */
        }
        
        h1, h2, h3 {
            font-family: 'Inter', sans-serif;
            letter-spacing: -0.025em;
        }

        .code-font {
            font-family: 'JetBrains Mono', monospace;
        }

        .gradient-text {
            background: linear-gradient(to right, #818cf8, #38bdf8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        canvas {
            border: 1px solid #334155;
            border-radius: 0.5rem;
            background-color: #1e293b;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
            height: auto;
        }

        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 5px;
            background: #475569;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #38bdf8;
            cursor: pointer;
        }
    </style>
</head>
<body class="antialiased selection:bg-indigo-500 selection:text-white">

    <!-- Hero Section -->
    <header class="max-w-4xl mx-auto pt-20 pb-12 px-6 text-center">
       
        <h1 class="text-5xl md:text-6xl font-extrabold mb-6 text-white tracking-tight">
            Lifecycle of a <br><span class="gradient-text">SQL Query</span>
        </h1>
        <p class="text-xl text-slate-400 max-w-2xl mx-auto mb-8">
            When you type <span class="code-font bg-slate-800 px-2 py-1 rounded text-yellow-300">SELECT * FROM users WHERE id = 42</span>, what actually happens inside MySQL? Let's break down the 7 phases of execution.
        </p>
    </header>

    <main class="max-w-4xl mx-auto px-6 pb-24 space-y-24">

        <!-- Phase 1 & 2: Connection & Parsing -->
        <section>
            <div class="border-l-4 border-indigo-500 pl-6 mb-8">
                <h2 class="text-3xl font-bold text-white mb-2">Phase 1 & 2: Connection & Parsing</h2>
                <p class="text-slate-400">The "Front Desk" of the database.</p>
            </div>
            
            <div class="prose prose-invert max-w-none text-slate-300 mb-8">
                <p>
                    When your application sends a query, it doesn't just float into the database. First, the <strong>Connection Manager</strong> assigns a dedicated thread (or grabs one from the pool) to handle your request. This thread initializes memory pools (MEM_ROOT) and prepares context.
                </p>
                <p>
                    Next, the <strong>Parser</strong> takes your raw text string and breaks it down. This happens in two steps:
                </p>
                <ul class="list-disc pl-5 space-y-2 text-slate-400">
                    <li><strong>Lexical Analysis:</strong> Breaking string characters into "Tokens" (e.g., <span class="code-font text-xs bg-slate-800 px-1">SELECT_SYM</span>, <span class="code-font text-xs bg-slate-800 px-1">IDENT</span>).</li>
                    <li><strong>Syntactic Analysis:</strong> Building a Parse Tree to validate grammar.</li>
                </ul>
            </div>

            <!-- Interactive Module 1 -->
            <div class="bg-slate-800/50 p-6 rounded-xl border border-slate-700">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold text-white">Simulation: Thread Assignment & Tokenization</h3>
                    <div class="space-x-2">
                        <button id="btn-phase1-run" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 text-white rounded-md text-sm font-medium transition-colors">
                            Send Query
                        </button>
                    </div>
                </div>
                
                <canvas id="canvas-phase1" width="800" height="300"></canvas>
                
                <div class="mt-4 grid grid-cols-2 gap-4 text-sm text-slate-400">
                    <div class="bg-slate-900 p-3 rounded">
                        <span class="block text-xs uppercase tracking-wide text-slate-500 mb-1">Status</span>
                        <span id="p1-status" class="text-yellow-400 font-mono">Waiting for client...</span>
                    </div>
                    <div class="bg-slate-900 p-3 rounded">
                        <span class="block text-xs uppercase tracking-wide text-slate-500 mb-1">Tokens Generated</span>
                        <span id="p1-tokens" class="font-mono text-green-400">[]</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- Phase 3 & 4: Resolution & Optimization -->
        <section>
            <div class="border-l-4 border-emerald-500 pl-6 mb-8">
                <h2 class="text-3xl font-bold text-white mb-2">Phase 3 & 4: Resolution & Optimization</h2>
                <p class="text-slate-400">The "Strategist" planning the route.</p>
            </div>

            <div class="prose prose-invert max-w-none text-slate-300 mb-8">
                <p>
                    Before execution, the <strong>Resolver</strong> checks if the table <code>users</code> actually exists and if you have permission to see it. It resolves <code>*</code> into actual column names.
                </p>
                <p>
                    Then, the <strong>Optimizer</strong> calculates the cost of different approaches. For a point query (`id = 42`), the choice is obvious, but the math still happens.
                </p>
            </div>

            <!-- Interactive Module 2 -->
            <div class="bg-slate-800/50 p-6 rounded-xl border border-slate-700">
                <div class="flex flex-col md:flex-row gap-8 items-start">
                    <div class="w-full md:w-1/2">
                        <h3 class="text-lg font-semibold text-white mb-4">Cost Calculator</h3>
                        <p class="text-sm text-slate-400 mb-4">
                            Adjust the table size to see how the Optimizer compares a Full Table Scan vs. a B+ Tree Index Lookup.
                        </p>
                        
                        <label class="block text-sm font-medium text-slate-300 mb-2">Total Rows in Table</label>
                        <input type="range" id="slider-rows" min="1000" max="1000000" step="1000" value="100000" class="slider mb-2">
                        <div class="flex justify-between text-xs text-slate-500 mb-6">
                            <span>1k Rows</span>
                            <span id="row-display" class="text-indigo-400 font-bold">100,000 Rows</span>
                            <span>1M Rows</span>
                        </div>

                        <div class="space-y-3">
                            <div class="p-3 bg-red-900/20 border border-red-900/50 rounded flex justify-between items-center">
                                <div>
                                    <div class="text-red-400 font-bold">Full Table Scan</div>
                                    <div class="text-xs text-red-300/70">Complexity: O(N)</div>
                                </div>
                                <div class="text-right">
                                    <div id="cost-scan" class="text-xl font-mono text-white">100,000</div>
                                    <div class="text-xs text-slate-500">Cost Units</div>
                                </div>
                            </div>

                            <div class="p-3 bg-emerald-900/20 border border-emerald-900/50 rounded flex justify-between items-center">
                                <div>
                                    <div class="text-emerald-400 font-bold">Index Lookup (ref)</div>
                                    <div class="text-xs text-emerald-300/70">Complexity: O(log N)</div>
                                </div>
                                <div class="text-right">
                                    <div id="cost-index" class="text-xl font-mono text-white">3</div>
                                    <div class="text-xs text-slate-500">Cost Units (Levels)</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="w-full md:w-1/2 flex items-center justify-center bg-slate-900 rounded-lg p-4 h-64">
                         <canvas id="canvas-optimizer" width="300" height="200"></canvas>
                    </div>
                </div>
            </div>
        </section>

        <!-- Phase 5: InnoDB Execution -->
        <section>
            <div class="border-l-4 border-yellow-500 pl-6 mb-8">
                <h2 class="text-3xl font-bold text-white mb-2">Phase 5: B+ Tree Execution</h2>
                <p class="text-slate-400">The "Librarian" running the search.</p>
            </div>

            <div class="prose prose-invert max-w-none text-slate-300 mb-8">
                <p>
                    The Executor calls the storage engine (InnoDB). InnoDB doesn't scan the whole file; it uses the <strong>Primary Key B+ Tree</strong>.
                </p>
                <p>
                    A B+ tree is short and fat. Even with millions of rows, the tree is usually only 3-4 levels deep. This means we only need to read 3-4 pages of data (16KB each) to find exactly what we want.
                </p>
            </div>

            <!-- Interactive Module 3 -->
            <div class="bg-slate-800/50 p-6 rounded-xl border border-slate-700">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold text-white">Visualizing B+ Tree Traversal</h3>
                    <div class="space-x-2">
                        <button id="btn-btree-search" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-500 text-white rounded-md text-sm font-medium transition-colors">
                            Find ID: 42
                        </button>
                         <button id="btn-btree-reset" class="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-md text-sm font-medium transition-colors">
                            Reset
                        </button>
                    </div>
                </div>

                <canvas id="canvas-btree" width="800" height="350"></canvas>
                
                <div class="mt-4 p-4 bg-slate-900 rounded border-l-2 border-yellow-500">
                    <p id="btree-log" class="font-mono text-sm text-slate-300">System Ready. Click 'Find ID: 42' to start traversal.</p>
                </div>
            </div>
        </section>

        <!-- Phase 6 & 7: Buffer Pool & Latency -->
        <section>
            <div class="border-l-4 border-pink-500 pl-6 mb-8">
                <h2 class="text-3xl font-bold text-white mb-2">Phase 6: Buffer Pool & I/O</h2>
                <p class="text-slate-400">The "Warehouse" vs. The "Backpack".</p>
            </div>

            <div class="prose prose-invert max-w-none text-slate-300 mb-8">
                <p>
                    Once the correct page is identified in the B+ Tree, InnoDB checks the <strong>Buffer Pool</strong> (memory). 
                </p>
                <ul class="list-disc pl-5 space-y-2 text-slate-400">
                    <li><strong>Cache Hit (RAM):</strong> ~100 nanoseconds. Instant.</li>
                    <li><strong>Cache Miss (Disk):</strong> ~10 milliseconds. 100,000x slower!</li>
                </ul>
            </div>

            <!-- Interactive Module 4 -->
            <div class="bg-slate-800/50 p-6 rounded-xl border border-slate-700">
                <h3 class="text-lg font-semibold text-white mb-4">Latency Simulator</h3>
                <p class="text-sm text-slate-400 mb-6">
                    This simulation is scaled down. If RAM access is 1 pixel of movement, Disk access would be a kilometer. Here, we just slow it down enough to feel the pain.
                </p>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <!-- Buffer Pool Status -->
                    <div class="bg-slate-900 p-4 rounded-lg">
                        <h4 class="text-sm font-bold text-slate-500 uppercase tracking-wider mb-4">Buffer Pool State</h4>
                        <div id="buffer-grid" class="grid grid-cols-8 gap-1 mb-4">
                            <!-- JS Generates Grid -->
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-slate-500">Green = Cached Page</span>
                            <button id="btn-flush-cache" class="text-xs text-red-400 hover:text-red-300 underline">Flush Cache</button>
                        </div>
                    </div>

                    <!-- Action Area -->
                    <div class="flex flex-col justify-center space-y-6">
                        <div class="space-y-2">
                            <div class="flex justify-between text-sm">
                                <span class="text-slate-300">Requesting Page #42...</span>
                                <span id="io-timer" class="font-mono text-slate-400">0 ms</span>
                            </div>
                            <div class="h-4 bg-slate-700 rounded-full overflow-hidden">
                                <div id="io-progress" class="h-full bg-indigo-500 w-0 transition-all duration-75"></div>
                            </div>
                        </div>

                        <button id="btn-request-page" class="w-full py-3 bg-pink-600 hover:bg-pink-500 text-white font-bold rounded shadow-lg transition-transform active:scale-95">
                            Fetch Page #42
                        </button>

                        <div id="io-result" class="text-center text-sm min-h-[20px]"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Conclusion -->
        <section class="border-t border-slate-800 pt-12 text-center">
            <h2 class="text-2xl font-bold text-white mb-4">The Result</h2>
            <p class="text-slate-400 max-w-2xl mx-auto mb-8">
                After the row is retrieved from the Buffer Pool, MySQL checks MVCC visibility (is this row valid for my transaction?), formats the result packet, and sends it back to the client. All of this usually happens in less than 1 millisecond for a cached point query.
            </p>
        </section>

    </main>

    <footer class="bg-slate-900 text-slate-500 py-8 text-center text-sm border-t border-slate-800">
    </footer>

    <!-- JAVASCRIPT LOGIC -->
    <script>
        /**
         * MODULE 1: Connection & Parser Animation
         */
        (function() {
            const canvas = document.getElementById('canvas-phase1');
            const ctx = canvas.getContext('2d');
            const btn = document.getElementById('btn-phase1-run');
            const statusEl = document.getElementById('p1-status');
            const tokenEl = document.getElementById('p1-tokens');

            let animationState = 'idle'; // idle, connecting, parsing, done
            let packetX = 50;
            let packetY = 150;
            let tokens = [];
            let frameId;

            // Visual elements
            const clientX = 50;
            const threadPoolX = 300;
            const parserX = 600;

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw Architecture
                ctx.fillStyle = '#334155';
                
                // Client Box
                ctx.fillStyle = '#475569';
                ctx.fillRect(20, 100, 80, 100);
                ctx.fillStyle = '#fff';
                ctx.font = '12px Inter';
                ctx.fillText("Client", 40, 155);

                // Thread Pool Box
                ctx.fillStyle = '#1e293b';
                ctx.strokeStyle = '#6366f1';
                ctx.lineWidth = 2;
                ctx.strokeRect(250, 50, 150, 200);
                ctx.fillStyle = '#818cf8';
                ctx.fillText("Connection Manager", 265, 80);
                
                // Threads
                for(let i=0; i<3; i++) {
                    ctx.fillStyle = (animationState !== 'idle' && i === 1) ? '#818cf8' : '#334155';
                    ctx.fillRect(270, 100 + (i*40), 110, 30);
                    ctx.fillStyle = '#fff';
                    ctx.fillText(`Thread ${i+1}`, 280, 120 + (i*40));
                }

                // Parser Box
                ctx.fillStyle = '#1e293b';
                ctx.strokeStyle = '#10b981';
                ctx.strokeRect(550, 50, 200, 200);
                ctx.fillStyle = '#34d399';
                ctx.fillText("Parser (Bison/Yacc)", 580, 80);

                // Animation Logic
                if (animationState === 'connecting') {
                    // Draw Packet
                    ctx.beginPath();
                    ctx.arc(packetX, packetY, 10, 0, Math.PI * 2);
                    ctx.fillStyle = '#facc15'; // Yellow
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.fillText("SQL", packetX-10, packetY-15);

                    if (packetX < 325) {
                        packetX += 5; // Move to thread
                    } else {
                        statusEl.innerText = "Thread Assigned. Forwarding to Parser...";
                        statusEl.className = "text-indigo-400 font-mono";
                        animationState = 'forwarding';
                    }
                } else if (animationState === 'forwarding') {
                    // Packet moves to Parser
                    ctx.beginPath();
                    ctx.arc(packetX, packetY, 10, 0, Math.PI * 2);
                    ctx.fillStyle = '#facc15';
                    ctx.fill();

                    if (packetX < 650) {
                        packetX += 5;
                    } else {
                        statusEl.innerText = "Lexical Analysis in progress...";
                        statusEl.className = "text-emerald-400 font-mono";
                        animationState = 'parsing';
                        setTimeout(tokenize, 500);
                    }
                } else if (animationState === 'parsing') {
                    // Draw Tokens appearing
                    let yPos = 110;
                    tokens.forEach((token, idx) => {
                        ctx.fillStyle = '#334155';
                        ctx.fillRect(570, yPos, 160, 25);
                        ctx.fillStyle = '#a7f3d0';
                        ctx.fillText(token, 580, yPos + 17);
                        yPos += 30;
                    });
                }
            }

            function tokenize() {
                const fullTokens = ['SELECT_SYM', 'IDENT "users"', 'WHERE_SYM', 'IDENT "id"', 'EQ_SYM', 'INT "42"'];
                let count = 0;
                const interval = setInterval(() => {
                    if (count >= fullTokens.length) {
                        clearInterval(interval);
                        statusEl.innerText = "Parse Tree Built. Ready for Optimizer.";
                        animationState = 'done';
                        return;
                    }
                    tokens.push(fullTokens[count]);
                    tokenEl.innerText = '[' + tokens.map(t => `'${t.split(' ')[0]}'`).join(', ') + ']';
                    count++;
                }, 300);
            }

            function animate() {
                draw();
                if(animationState !== 'done') {
                    frameId = requestAnimationFrame(animate);
                } else {
                     draw(); // One last draw
                }
            }

            btn.addEventListener('click', () => {
                if (animationState !== 'idle' && animationState !== 'done') return;
                
                // Reset
                packetX = 50;
                tokens = [];
                tokenEl.innerText = '[]';
                statusEl.innerText = 'Sending Query Packet...';
                statusEl.className = 'text-yellow-400 font-mono';
                animationState = 'connecting';
                animate();
            });

            // Initial draw
            draw();
        })();


        /**
         * MODULE 2: Optimizer Cost Visualizer
         */
        (function() {
            const slider = document.getElementById('slider-rows');
            const display = document.getElementById('row-display');
            const costScanEl = document.getElementById('cost-scan');
            const costIndexEl = document.getElementById('cost-index');
            const canvas = document.getElementById('canvas-optimizer');
            const ctx = canvas.getContext('2d');

            function update() {
                const rows = parseInt(slider.value);
                const kRows = (rows / 1000).toFixed(0) + (rows >= 1000000 ? 'M' : 'k');
                display.innerText = rows.toLocaleString() + " Rows";

                // Calculations
                // Cost 1: Table Scan = rows * 0.1 (evaluate cost) + read cost
                const scanCost = Math.round(rows * 0.2); // Simplified
                // Cost 2: Index = Log_base_100(rows) roughly
                const levels = Math.max(1, Math.ceil(Math.log(rows) / Math.log(100)));
                const indexCost = levels + 1; // Traversal + 1 read

                costScanEl.innerText = scanCost.toLocaleString();
                costIndexEl.innerText = indexCost;

                drawGraph(scanCost, indexCost);
            }

            function drawGraph(scan, index) {
                ctx.clearRect(0,0, canvas.width, canvas.height);
                
                // Bars
                const barWidth = 60;
                const bottom = 180;
                
                // Scan Bar (Red) - Logarithmic scaling for visualization
                const scanHeight = Math.min(150, Math.log(scan) * 15);
                ctx.fillStyle = '#f87171';
                ctx.fillRect(60, bottom - scanHeight, barWidth, scanHeight);
                ctx.fillStyle = '#fff';
                ctx.fillText("Scan", 70, bottom + 20);

                // Index Bar (Green)
                const indexHeight = Math.min(150, Math.log(index * 10000) * 10); // Artificial scale to make it visible
                ctx.fillStyle = '#34d399';
                ctx.fillRect(180, bottom - indexHeight, barWidth, indexHeight);
                ctx.fillStyle = '#fff';
                ctx.fillText("Index", 190, bottom + 20);
                
                // Title
                ctx.fillStyle = '#94a3b8';
                ctx.fillText("Relative Cost (Log Scale)", 80, 20);
            }

            slider.addEventListener('input', update);
            update(); // Init
        })();


        /**
         * MODULE 3: B+ Tree Traversal
         */
        (function() {
            const canvas = document.getElementById('canvas-btree');
            const ctx = canvas.getContext('2d');
            const btnRun = document.getElementById('btn-btree-search');
            const btnReset = document.getElementById('btn-btree-reset');
            const logEl = document.getElementById('btree-log');

            // B+ Tree Data Structure (Visual Representation)
            const tree = {
                root: { x: 400, y: 50, val: "Root [1-100]", type: 'node', 
                    children: [
                        { x: 200, y: 150, val: "[1-50]", type: 'node', 
                            children: [
                                { x: 100, y: 250, val: "Leaf [1-25]", type: 'leaf', values: [1, 10, 20] },
                                { x: 300, y: 250, val: "Leaf [26-50]", type: 'leaf', values: [30, 42, 50] } // Target here
                            ]
                        },
                        { x: 600, y: 150, val: "[51-100]", type: 'node',
                             children: [
                                { x: 500, y: 250, val: "Leaf [51-75]", type: 'leaf', values: [55, 60] },
                                { x: 700, y: 250, val: "Leaf [76-100]", type: 'leaf', values: [80, 99] }
                            ]
                        }
                    ]
                }
            };

            let currentPath = []; // Array of nodes being visited
            let animationStep = 0;
            let targetId = 42;
            let isAnimating = false;

            function drawNode(node, isActive) {
                // Connection lines
                if (node.children) {
                    node.children.forEach(child => {
                        ctx.beginPath();
                        ctx.moveTo(node.x, node.y + 20);
                        ctx.lineTo(child.x, child.y - 20);
                        ctx.strokeStyle = '#475569';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    });
                }

                // Node box
                ctx.fillStyle = isActive ? '#eab308' : '#1e293b'; // Yellow if active
                ctx.strokeStyle = isActive ? '#fef08a' : '#475569';
                ctx.lineWidth = isActive ? 3 : 1;
                
                const width = node.type === 'leaf' ? 100 : 120;
                ctx.fillRect(node.x - width/2, node.y - 20, width, 40);
                ctx.strokeRect(node.x - width/2, node.y - 20, width, 40);

                // Text
                ctx.fillStyle = isActive ? '#000' : '#cbd5e1';
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(node.val, node.x, node.y + 5);

                // Draw specific value if found in leaf
                if (isActive && node.type === 'leaf' && node.values.includes(targetId)) {
                    ctx.fillStyle = '#10b981'; // Green
                    ctx.font = 'bold 14px Inter';
                    ctx.fillText(`FOUND ID: ${targetId}`, node.x, node.y + 40);
                }

                // Recursion
                if (node.children) {
                    node.children.forEach(child => drawNode(child, currentPath.includes(child)));
                }
            }

            function render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawNode(tree.root, currentPath.includes(tree.root));
            }

            function runSearch() {
                if (isAnimating) return;
                isAnimating = true;
                currentPath = [tree.root];
                animationStep = 0;
                logEl.innerText = "Step 1: Accessing Root Page (Cached in Memory)...";
                render();

                const steps = [
                    () => {
                        // Go left
                        currentPath.push(tree.root.children[0]);
                        logEl.innerText = "Step 2: ID 42 is < 50. Moving to Left Branch...";
                        render();
                    },
                    () => {
                        // Go right leaf
                        currentPath.push(tree.root.children[0].children[1]);
                        logEl.innerText = "Step 3: ID 42 is > 25. Moving to Leaf Page...";
                        render();
                    },
                    () => {
                        logEl.innerHTML = "<span class='text-green-400 font-bold'>Step 4: Scanning Leaf Page... Record Found! Pointer returned.</span>";
                        render();
                        isAnimating = false;
                    }
                ];

                let stepCount = 0;
                const interval = setInterval(() => {
                    if (stepCount >= steps.length) {
                        clearInterval(interval);
                        return;
                    }
                    steps[stepCount]();
                    stepCount++;
                }, 1000);
            }

            btnRun.addEventListener('click', runSearch);
            btnReset.addEventListener('click', () => {
                currentPath = [];
                isAnimating = false;
                logEl.innerText = "System Ready.";
                render();
            });

            // Init
            render();
        })();

        /**
         * MODULE 4: Buffer Pool Simulator
         */
        (function() {
            const gridEl = document.getElementById('buffer-grid');
            const btnReq = document.getElementById('btn-request-page');
            const btnFlush = document.getElementById('btn-flush-cache');
            const progressEl = document.getElementById('io-progress');
            const timerEl = document.getElementById('io-timer');
            const resultEl = document.getElementById('io-result');

            let bufferPool = new Set();
            const PAGE_ID = 42;
            const TOTAL_PAGES = 32;

            // Init Grid
            function renderGrid() {
                gridEl.innerHTML = '';
                for(let i=0; i<TOTAL_PAGES; i++) {
                    const div = document.createElement('div');
                    div.className = 'w-4 h-4 rounded-sm transition-colors duration-300 ' + 
                                    (bufferPool.has(i) ? 'bg-emerald-500 shadow-[0_0_8px_rgba(16,185,129,0.6)]' : 'bg-slate-700');
                    if(i === PAGE_ID) div.id = 'target-page-indicator';
                    gridEl.appendChild(div);
                }
            }

            function simulateFetch() {
                if(btnReq.disabled) return;
                btnReq.disabled = true;
                resultEl.innerText = '';
                
                if (bufferPool.has(PAGE_ID)) {
                    // Cache Hit
                    timerEl.innerText = "< 0.1 ms";
                    progressEl.style.transition = 'none';
                    progressEl.style.width = '100%';
                    resultEl.innerHTML = "<span class='text-emerald-400 font-bold'>CACHE HIT! (RAM speed)</span>";
                    
                    setTimeout(() => {
                         progressEl.style.width = '0%';
                         btnReq.disabled = false;
                    }, 1000);

                } else {
                    // Cache Miss (Disk I/O)
                    timerEl.innerText = "...";
                    progressEl.style.transition = 'width 2s ease-out'; // Simulate slow disk
                    progressEl.style.width = '100%';
                    resultEl.innerHTML = "<span class='text-red-400 animate-pulse'>Reading from Disk... (Slow)</span>";

                    let ms = 0;
                    const timerInterval = setInterval(() => {
                        ms += 0.5;
                        timerEl.innerText = ms.toFixed(1) + " ms";
                    }, 100);

                    setTimeout(() => {
                        clearInterval(timerInterval);
                        timerEl.innerText = "12.4 ms";
                        bufferPool.add(PAGE_ID); // Add to cache
                        // Fill some random others to simulate locality/read-ahead
                        bufferPool.add(PAGE_ID+1); 
                        renderGrid();
                        resultEl.innerHTML = "<span class='text-yellow-400'>Page Loaded into Buffer Pool. Next read will be fast.</span>";
                        
                        setTimeout(() => {
                             progressEl.style.transition = 'none';
                             progressEl.style.width = '0%';
                             btnReq.disabled = false;
                        }, 1000);

                    }, 2000);
                }
            }

            btnReq.addEventListener('click', simulateFetch);
            
            btnFlush.addEventListener('click', () => {
                bufferPool.clear();
                renderGrid();
                resultEl.innerText = "Buffer Pool Flushed.";
            });

            renderGrid();
        })();
    </script>
</body>
</html>
