<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google File System</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        .node-label { font-size: 10px; pointer-events: none; fill: #475569; }
        .interactive-canvas { background: white; border-radius: 8px; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1); }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Shared Components ---

        const Card = ({ title, children, className = "" }) => (
            <div className={`bg-white rounded-lg shadow p-6 border border-slate-200 ${className}`}>
                <h3 className="text-lg font-bold text-slate-800 mb-4 border-b pb-2">{title}</h3>
                {children}
            </div>
        );

        const Button = ({ onClick, disabled, children, color = "blue" }) => {
            const colors = {
                blue: "bg-blue-600 hover:bg-blue-700 text-white",
                green: "bg-green-600 hover:bg-green-700 text-white",
                red: "bg-red-600 hover:bg-red-700 text-white",
                slate: "bg-slate-200 hover:bg-slate-300 text-slate-800"
            };
            return (
                <button 
                    onClick={onClick} 
                    disabled={disabled}
                    className={`${colors[color]} px-4 py-2 rounded font-medium transition-all disabled:opacity-50 disabled:cursor-not-allowed`}
                >
                    {children}
                </button>
            );
        };

        const InfoTooltip = ({ content, x, y }) => {
            if (!content) return null;
            return (
                <div 
                    className="absolute bg-slate-800 text-white text-xs p-3 rounded shadow-xl z-50 w-64 pointer-events-none"
                    style={{ left: x + 10, top: y + 10 }}
                >
                    <pre className="whitespace-pre-wrap font-mono">{content}</pre>
                </div>
            );
        };

        // --- Module 1: Architecture & "God Mode" ---

        const ModuleArchitecture = () => {
            const svgRef = useRef(null);
            const [hoverInfo, setHoverInfo] = useState(null);
            const [selectedFile, setSelectedFile] = useState(null);

            // Mock Data for Files
            const fileSystem = {
                "/user/home/research_data.dat": {
                    size: "128MB",
                    chunks: [
                        { id: "C1", locations: ["cs-0-1", "cs-1-2", "cs-2-1"] }, // Spans 3 racks
                        { id: "C2", locations: ["cs-0-2", "cs-1-3", "cs-2-2"] }
                    ]
                },
                "/sys/logs/app.log": {
                    size: "64MB",
                    chunks: [
                        { id: "C3", locations: ["cs-0-4", "cs-0-5", "cs-1-4"] } // Poorly replicated (mostly rack 0)
                    ]
                }
            };

            useEffect(() => {
                const width = 800;
                const height = 500;
                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();

                const racks = 3;
                const nodesPerRack = 10;
                
                // --- Visualizing Racks ---
                const rackWidth = 120;
                const rackHeight = 300;
                const rackSpacing = 160;
                const startX = 200;
                const startY = 100;

                const rackGroup = svg.append("g");

                // Draw Rack Containers
                for(let r=0; r<racks; r++) {
                    rackGroup.append("rect")
                        .attr("x", startX + (r * rackSpacing))
                        .attr("y", startY)
                        .attr("width", rackWidth)
                        .attr("height", rackHeight)
                        .attr("fill", "#f1f5f9")
                        .attr("stroke", "#cbd5e1")
                        .attr("rx", 8);
                    
                    rackGroup.append("text")
                        .attr("x", startX + (r * rackSpacing) + rackWidth/2)
                        .attr("y", startY - 10)
                        .attr("text-anchor", "middle")
                        .attr("class", "text-xs font-bold fill-slate-500")
                        .text(`Rack ${r+1}`);
                }

                // --- Nodes ---
                let nodes = [{ id: "master", type: "master", label: "Master", x: 100, y: height/2 }];
                
                // Add Chunkservers with fixed positions inside racks
                for(let r=0; r<racks; r++) {
                    for(let i=0; i<nodesPerRack; i++) {
                        nodes.push({ 
                            id: `cs-${r}-${i}`, 
                            type: "chunkserver", 
                            rack: r,
                            x: startX + (r * rackSpacing) + (rackWidth/2),
                            y: startY + 30 + (i * 25)
                        });
                    }
                }

                // --- Drawing Nodes ---
                const nodeGroup = svg.append("g");

                // Draw Connections (Master to Racks - Logical)
                if (selectedFile) {
                    // Draw lines from Master to active Chunkservers
                    const activeChunks = fileSystem[selectedFile].chunks;
                    const activeCS = new Set(activeChunks.flatMap(c => c.locations));

                    activeCS.forEach(csId => {
                        const target = nodes.find(n => n.id === csId);
                        if (target) {
                            nodeGroup.append("line")
                                .attr("x1", nodes[0].x)
                                .attr("y1", nodes[0].y)
                                .attr("x2", target.x)
                                .attr("y2", target.y)
                                .attr("stroke", "#3b82f6")
                                .attr("stroke-width", 1)
                                .attr("opacity", 0.3)
                                .attr("stroke-dasharray", "5,5");
                        }
                    });
                }

                nodes.forEach(d => {
                    const isMaster = d.type === 'master';
                    const isActive = selectedFile && 
                        fileSystem[selectedFile].chunks.some(c => c.locations.includes(d.id));

                    const circle = nodeGroup.append("circle")
                        .attr("cx", d.x)
                        .attr("cy", d.y)
                        .attr("r", isMaster ? 30 : 8)
                        .attr("fill", () => {
                            if (isMaster) return "#7c3aed";
                            if (isActive) return "#ef4444"; // Highlight active CS
                            return "#16a34a"; // Normal CS
                        })
                        .attr("stroke", "white")
                        .attr("stroke-width", 2)
                        .style("cursor", "pointer")
                        .style("transition", "fill 0.3s");

                    // Interactions
                    circle.on("mouseover", (event) => {
                        let content = "";
                        if(isMaster) {
                            content = `MASTER (RAM):\n-------------\nFiles: ${Object.keys(fileSystem).length}\n\nNAMESPACE LOOKUP:\n${selectedFile ? `${selectedFile} \n-> [Chunk handles...]` : "(Select a file to see mapping)"}`;
                        } else {
                            content = `CHUNKSERVER (DISK):\n------------------\nID: ${d.id}\nRack: ${d.rack + 1}\n\n${isActive ? ">> HOLDING REPLICA <<" : "Idle"}`;
                        }
                        setHoverInfo({ content, x: event.pageX, y: event.pageY });
                    })
                    .on("mouseout", () => setHoverInfo(null));

                    if (isMaster) {
                        nodeGroup.append("text")
                            .attr("x", d.x).attr("y", d.y + 5)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .attr("class", "text-xs font-bold pointer-events-none")
                            .text("RAM");
                    }
                });

            }, [selectedFile]);

            return (
                <div className="flex flex-col gap-4">
                    <div className="flex justify-between items-center bg-blue-50 p-4 rounded border border-blue-100">
                        <div>
                            <h4 className="font-bold text-slate-700 text-sm mb-2">Simulate File Inspection:</h4>
                            <div className="flex gap-2">
                                {Object.keys(fileSystem).map(f => (
                                    <button 
                                        key={f}
                                        onClick={() => setSelectedFile(f)}
                                        className={`text-xs px-3 py-1 rounded border ${
                                            selectedFile === f ? "bg-blue-600 text-white border-blue-600" : "bg-white text-slate-600 hover:bg-slate-50"
                                        }`}
                                    >
                                        {f}
                                    </button>
                                ))}
                                <button onClick={() => setSelectedFile(null)} className="text-xs px-3 py-1 text-slate-500 hover:text-slate-700">Clear</button>
                            </div>
                        </div>
                        <div className="text-xs text-slate-600 max-w-xs text-right hidden md:block">
                            Select a file to see how the Master (Purple) maps a Logical Filename to Physical Replicas (Red) across Racks.
                        </div>
                    </div>

                    <div className="relative">
                        <svg ref={svgRef} viewBox="0 0 800 500" className="w-full h-auto interactive-canvas bg-slate-50 border border-slate-200" />
                        {hoverInfo && <InfoTooltip {...hoverInfo} />}
                    </div>
                </div>
            );
        };

        // --- Module 2: The Read Flow ---

        const ModuleReadFlow = () => {
            const svgRef = useRef(null);
            const [step, setStep] = useState(0); // 0: Idle, 1: Miss, 2: Hit

            const animateRead = (isHit) => {
                const svg = d3.select(svgRef.current);
                svg.selectAll(".packet").remove();

                const clientPos = { x: 100, y: 250 };
                const masterPos = { x: 400, y: 100 };
                const chunkServerPos = { x: 400, y: 400 };

                const packet = svg.append("circle")
                    .attr("class", "packet")
                    .attr("r", 8)
                    .attr("cx", clientPos.x)
                    .attr("cy", clientPos.y)
                    .attr("fill", "#ef4444"); // Red for request

                if (!isHit) {
                    // Miss Flow: Client -> Master -> Client -> CS
                    packet.transition().duration(1000).attr("cx", masterPos.x).attr("cy", masterPos.y) // To Master
                        .transition().duration(500).attr("fill", "#3b82f6") // Turn Blue (Metadata)
                        .transition().duration(1000).attr("cx", clientPos.x).attr("cy", clientPos.y) // Back to Client
                        .on("end", () => {
                             // Light up cache
                             d3.select("#client-cache-box").style("opacity", 1);
                             
                             // Client to Data
                             svg.append("circle")
                                .attr("class", "packet")
                                .attr("r", 8)
                                .attr("cx", clientPos.x)
                                .attr("cy", clientPos.y)
                                .attr("fill", "#16a34a") // Green for Data Req
                                .transition().duration(1000).attr("cx", chunkServerPos.x).attr("cy", chunkServerPos.y)
                                .on("end", () => setStep(2));
                        });
                } else {
                    // Hit Flow: Client -> CS (Bypassing Master)
                    packet.attr("fill", "#16a34a")
                        .transition().duration(1000).attr("cx", chunkServerPos.x).attr("cy", chunkServerPos.y)
                        .on("end", () => {
                            // Pulse animation on CS
                            svg.append("circle").attr("cx", chunkServerPos.x).attr("cy", chunkServerPos.y)
                                .attr("r", 10).attr("fill", "none").attr("stroke", "#16a34a")
                                .transition().duration(500).attr("r", 40).style("opacity", 0).remove();
                        });
                }
            };

            const reset = () => {
                setStep(0);
                d3.select("#client-cache-box").style("opacity", 0.3);
                d3.select(svgRef.current).selectAll(".packet").remove();
            };

            return (
                <div className="flex flex-col items-center">
                    <div className="flex gap-4 mb-4">
                        <Button onClick={() => { setStep(1); animateRead(false); }} disabled={step !== 0}>
                            1. Read File X (Cold)
                        </Button>
                        <Button onClick={() => animateRead(true)} disabled={step !== 2} color="green">
                            2. Read File X (Cached)
                        </Button>
                        <Button onClick={reset} color="slate">Reset</Button>
                    </div>
                    
                    <div className="relative w-full max-w-2xl">
                        <svg ref={svgRef} viewBox="0 0 600 500" className="w-full interactive-canvas">
                            {/* Layout */}
                            {/* Master */}
                            <circle cx="400" cy="100" r="30" fill="#7c3aed" />
                            <text x="400" y="60" textAnchor="middle" className="text-sm font-bold">GFS Master</text>
                            
                            {/* Chunkserver */}
                            <rect x="360" y="370" width="80" height="60" rx="4" fill="#16a34a" />
                            <text x="400" y="450" textAnchor="middle" className="text-sm font-bold">Chunkserver</text>

                            {/* Client */}
                            <rect x="60" y="220" width="80" height="60" rx="4" fill="#2563eb" />
                            <text x="100" y="300" textAnchor="middle" className="text-sm font-bold">Client</text>
                            
                            {/* Client Cache Visual */}
                            <g id="client-cache-box" opacity="0.3">
                                <rect x="70" y="235" width="60" height="30" fill="white" stroke="#2563eb" strokeWidth="2" />
                                <text x="100" y="255" textAnchor="middle" fontSize="10" fill="#2563eb">CACHE</text>
                            </g>

                            {/* Paths */}
                            <line x1="100" y1="220" x2="370" y2="100" stroke="#cbd5e1" strokeWidth="2" strokeDasharray="5,5" />
                            <line x1="100" y1="280" x2="360" y2="400" stroke="#cbd5e1" strokeWidth="2" />
                        </svg>
                        
                        <div className="absolute top-4 left-4 bg-yellow-50 p-3 rounded border border-yellow-200 text-sm w-64">
                            <strong>Status:</strong><br/>
                            {step === 0 && "Waiting for request..."}
                            {step === 1 && "Fetching metadata from Master..."}
                            {step === 2 && "Metadata Cached! Master is now bypassed."}
                        </div>
                    </div>
                </div>
            );
        };

        // --- Module 3: Write Flow (Pipelining) ---

        const ModuleWriteFlow = () => {
            const svgRef = useRef(null);
            const [status, setStatus] = useState("idle"); // idle, piping, control, done

            const runSimulation = () => {
                setStatus("piping");
                const svg = d3.select(svgRef.current);
                svg.selectAll(".data-chunk").remove();
                svg.selectAll(".control-signal").remove();

                // Coordinates
                const nodes = [
                    { id: 'client', x: 50, y: 150, color: '#2563eb' },
                    { id: 'p', x: 200, y: 150, color: '#16a34a' },
                    { id: 's1', x: 350, y: 150, color: '#16a34a' },
                    { id: 's2', x: 500, y: 150, color: '#16a34a' }
                ];

                // Phase A: Data Pipelining
                // We animate a large block "filling" the buffers.
                // To visualize pipelining, we send chunks that travel between nodes
                
                const sendData = (source, target, delay) => {
                    const chunk = svg.append("rect")
                        .attr("class", "data-chunk")
                        .attr("x", source.x)
                        .attr("y", source.y - 15)
                        .attr("width", 0)
                        .attr("height", 30)
                        .attr("fill", "#f59e0b") // Orange data
                        .attr("opacity", 0.7);

                    // Expand to simulate sending
                    chunk.transition().delay(delay).duration(1000)
                        .attr("width", target.x - source.x - 20)
                        .on("end", () => {
                            // "Fill" the target node
                            svg.append("rect")
                                .attr("x", target.x - 20).attr("y", target.y + 25)
                                .attr("width", 40).attr("height", 0)
                                .attr("fill", "#f59e0b")
                                .transition().duration(500)
                                .attr("y", target.y + 5).attr("height", 20);
                        });
                };

                // Pipeline: Client -> P, P -> S1, S1 -> S2
                sendData(nodes[0], nodes[1], 0);    // Client -> Primary
                sendData(nodes[1], nodes[2], 800);  // Primary -> S1 (starts before full arrival)
                sendData(nodes[2], nodes[3], 1600); // S1 -> S2

                // Phase B: Control Flow
                setTimeout(() => {
                    setStatus("control");
                    
                    // Client -> Primary (Write Request)
                    const controlDot = svg.append("circle")
                        .attr("class", "control-signal")
                        .attr("r", 5).attr("fill", "#ef4444")
                        .attr("cx", nodes[0].x).attr("cy", nodes[0].y - 40);
                    
                    controlDot.transition().duration(500)
                        .attr("cx", nodes[1].x).attr("cy", nodes[1].y - 40)
                        .on("end", () => {
                            // Primary flashes
                            svg.append("text").attr("x", nodes[1].x).attr("y", nodes[1].y - 50)
                                .text("SERIAL #1").attr("text-anchor", "middle").attr("font-size", "10px")
                                .transition().delay(1000).remove();
                            
                            // Primary -> Secondaries
                            [nodes[2], nodes[3]].forEach(target => {
                                svg.append("circle").attr("class", "control-signal").attr("r", 4).attr("fill", "#ef4444")
                                    .attr("cx", nodes[1].x).attr("cy", nodes[1].y - 40)
                                    .transition().duration(500)
                                    .attr("cx", target.x).attr("cy", target.y - 40);
                            });

                            setTimeout(() => setStatus("done"), 1000);
                        });

                }, 3000);
            };

            return (
                <div className="flex flex-col items-center">
                    <div className="flex gap-4 mb-4">
                        <Button onClick={runSimulation} disabled={status === "piping" || status === "control"}>
                            Push Data & Write
                        </Button>
                    </div>

                    <div className="w-full max-w-2xl bg-slate-50 border rounded-lg p-4">
                        <svg ref={svgRef} viewBox="0 0 600 300" className="w-full">
                            {/* Connections */}
                            <path d="M50 150 L500 150" stroke="#cbd5e1" strokeWidth="4" />
                            
                            {/* Nodes */}
                            {[ 
                                {l: "Client", x: 50, c: "#2563eb"},
                                {l: "Primary", x: 200, c: "#16a34a"},
                                {l: "Secondary A", x: 350, c: "#16a34a"},
                                {l: "Secondary B", x: 500, c: "#16a34a"}
                            ].map((n, i) => (
                                <g key={i} transform={`translate(${n.x}, 150)`}>
                                    <circle r="20" fill={n.c} />
                                    <text y="40" textAnchor="middle" className="text-xs font-bold">{n.l}</text>
                                    {/* Buffer Rect Container */}
                                    <rect x="-20" y="5" width="40" height="20" fill="white" stroke="#94a3b8" />
                                </g>
                            ))}

                            {/* Legend */}
                            <g transform="translate(50, 250)">
                                <rect width="20" height="10" fill="#f59e0b" />
                                <text x="25" y="10" fontSize="12">Data Flow (Heavy, Pipelined)</text>
                            </g>
                            <g transform="translate(300, 250)">
                                <circle r="5" fill="#ef4444" />
                                <text x="10" y="5" fontSize="12">Control Flow (Light, Serialized)</text>
                            </g>
                        </svg>
                    </div>
                    <div className="mt-4 text-center text-slate-600 h-8">
                        {status === 'idle' && "Ready to write."}
                        {status === 'piping' && "Phase 1: Pushing Data to all buffers (Linear Pipeline)..."}
                        {status === 'control' && "Phase 2: Sending Write Command (Serialized by Primary)..."}
                        {status === 'done' && "Write Committed!"}
                    </div>
                </div>
            );
        };

        // --- Module 4: Consistency & Atomic Appends ---

        const ModuleConsistency = () => {
            const [blocks, setBlocks] = useState([]);
            
            const append = (clientId) => {
                // Simulate network latency race
                const delay = Math.random() * 500;
                
                setTimeout(() => {
                    setBlocks(prev => {
                        // 20% chance of "failure" causing padding/undefined region
                        const failure = Math.random() > 0.8;
                        const newBlocks = [...prev];
                        
                        if (failure) {
                            newBlocks.push({ type: 'padding', width: 10 });
                        }
                        
                        newBlocks.push({ 
                            type: 'record', 
                            client: clientId, 
                            width: 30 
                        });
                        return newBlocks;
                    });
                }, delay);
            };

            return (
                <div className="flex flex-col items-center">
                    <div className="flex gap-8 mb-8">
                        <div className="flex flex-col items-center gap-2">
                            <span className="font-bold text-blue-600">Client A</span>
                            <Button onClick={() => append('A')} color="blue">Append Record</Button>
                        </div>
                        <div className="flex flex-col items-center gap-2">
                            <span className="font-bold text-purple-600">Client B</span>
                            <Button onClick={() => append('B')} color="red">Append Record</Button>
                        </div>
                    </div>
                    
                    <p className="mb-2 text-sm text-slate-500">Click both rapidly to simulate concurrency & padding.</p>

                    {/* The File Visualization */}
                    <div className="w-full max-w-2xl h-24 bg-slate-100 border-2 border-slate-300 rounded flex items-center px-2 overflow-hidden relative">
                        {blocks.map((b, i) => (
                            <div 
                                key={i}
                                className={`h-16 flex-shrink-0 border-r border-white/20 transition-all duration-300 ${
                                    b.type === 'padding' ? 'bg-slate-400 w-4' : 
                                    (b.client === 'A' ? 'bg-blue-500 w-12' : 'bg-purple-500 w-12')
                                }`}
                                title={b.type === 'padding' ? 'Undefined / Padding' : `Record from Client ${b.client}`}
                            >
                                {b.type === 'padding' && <span className="text-[8px] text-white block text-center mt-6">PAD</span>}
                                {b.type === 'record' && <span className="text-white font-bold block text-center mt-4">{b.client}</span>}
                            </div>
                        ))}
                        {blocks.length === 0 && <span className="absolute left-1/2 -translate-x-1/2 text-slate-400 italic">Empty File</span>}
                    </div>

                    <div className="mt-4 flex gap-4 text-sm">
                        <div className="flex items-center gap-1"><div className="w-4 h-4 bg-blue-500"></div> Defined (A)</div>
                        <div className="flex items-center gap-1"><div className="w-4 h-4 bg-purple-500"></div> Defined (B)</div>
                        <div className="flex items-center gap-1"><div className="w-4 h-4 bg-slate-400"></div> Inconsistent / Padding</div>
                    </div>
                </div>
            );
        };

        // --- Main App Container ---

        const App = () => {
            const [activeTab, setActiveTab] = useState(0);

            const tabs = [
                { 
                    title: "1. Architecture", 
                    component: <ModuleArchitecture />, 
                    desc: "GFS achieves scalability by decoupling Logical Metadata (RAM) from Physical Storage (Disk). The Master holds the map; Chunkservers hold the weight. Notice how replicas are distributed across 'Racks' to survive hardware failures." 
                },
                { title: "2. Read Flow", component: <ModuleReadFlow />, desc: "See how clients cache metadata to avoid bottling-necking the Master." },
                { title: "3. Write Flow", component: <ModuleWriteFlow />, desc: "Understand the decoupling of Data Flow (Pipelined, Bandwidth-optimized) and Control Flow (Serialized)." },
                { title: "4. Consistency", component: <ModuleConsistency />, desc: "Simulate 'Atomic Record Appends'. See how GFS trades byte-perfect consistency for performance using 'At Least Once' semantics." }
            ];

            return (
                <div className="min-h-screen pb-12">
                    <header className="bg-slate-900 text-white p-6 shadow-lg">
                        <div className="max-w-6xl mx-auto flex flex-col md:flex-row justify-between items-center">
                            <div>
                                <p className="text-slate-400 text-sm mt-1">Interactive visualization of the Google File System (SOSP '03)</p>
                            </div>
                            <div className="text-right text-xs text-slate-500 mt-4 md:mt-0">
                                Based on Ghemawat et al.
                            </div>
                        </div>
                    </header>

                    <main className="max-w-6xl mx-auto mt-8 px-4">
                        {/* Navigation */}
                        <div className="flex flex-wrap gap-2 mb-8 justify-center">
                            {tabs.map((t, i) => (
                                <button
                                    key={i}
                                    onClick={() => setActiveTab(i)}
                                    className={`px-4 py-3 rounded-lg font-medium text-sm transition-all ${
                                        activeTab === i 
                                        ? "bg-blue-600 text-white shadow-lg scale-105" 
                                        : "bg-white text-slate-600 hover:bg-slate-50 border border-slate-200"
                                    }`}
                                >
                                    {t.title}
                                </button>
                            ))}
                        </div>

                        {/* Content Area */}
                        <div className="animate-fade-in">
                            <Card title={tabs[activeTab].title} className="mb-4">
                                <p className="text-slate-600 mb-6 text-lg leading-relaxed border-l-4 border-blue-500 pl-4 bg-slate-50 py-2">
                                    {tabs[activeTab].desc}
                                </p>
                                {tabs[activeTab].component}
                            </Card>
                        </div>
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
