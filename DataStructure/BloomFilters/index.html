<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloom Filter: The Intuition Builder</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #f8fafc; padding: 40px; color: #334155; }
        .container { max-width: 900px; margin: 0 auto; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); }
        
        h1 { margin-top: 0; color: #1e293b; }
        .explanation { background: #eff6ff; padding: 15px; border-radius: 8px; border-left: 4px solid #3b82f6; margin-bottom: 20px; font-size: 0.95rem;}
        
        .controls { display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 15px; margin-bottom: 30px; align-items: end;}
        .input-group label { display: block; font-size: 0.85rem; font-weight: 600; margin-bottom: 5px; }
        .input-group input { width: 100%; padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; }
        button { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; transition: transform 0.1s;}
        button:active { transform: scale(0.98); }
        .btn-add { background: #3b82f6; color: white; }
        .btn-check { background: #10b981; color: white; }
        .btn-reset { background: #64748b; color: white; }

        /* The Grid */
        .array-container { margin: 30px 0; }
        .bit-labels { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.8rem; color: #94a3b8; }
        .bit-grid { display: flex; gap: 4px; flex-wrap: wrap; }
        .bit { 
            width: 40px; height: 50px; 
            background: #e2e8f0; 
            border-radius: 4px; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 0.75rem; color: #64748b; position: relative;
            cursor: help;
        }
        
        /* Bit States */
        .bit.active { background: #3b82f6; color: white; font-weight: bold; }
        .bit.collision { background: #f59e0b; } /* Orange if multiple items hit it */
        
        /* Hover Tooltip for Bits */
        .bit:hover::after {
            content: attr(data-sources);
            position: absolute; bottom: 110%; left: 50%; transform: translateX(-50%);
            background: #1e293b; color: white; padding: 5px 10px; border-radius: 4px;
            white-space: nowrap; font-size: 0.75rem; z-index: 10;
        }

        .status-box { background: #f1f5f9; padding: 20px; border-radius: 8px; font-family: monospace; }
        .log-item { margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #e2e8f0; }
        .tag { padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: bold; text-transform: uppercase; margin-right: 8px; }
        .tag.add { background: #dbeafe; color: #1e40af; }
        .tag.check { background: #d1fae5; color: #065f46; }
        .tag.error { background: #fee2e2; color: #991b1b; }
    </style>
</head>
<body>

<div class="container">
    <h1>Bloom Filter Visualizer</h1>
    <div class="explanation">
        <strong>How to learn:</strong> 
        1. Add "Apple". Watch which bits light up (Blue). <br>
        2. Add "Banana". If it hits a Blue bit, it turns <strong>Orange (Collision)</strong>. <br>
        3. Hover over any bit to see exactly <em>who</em> turned it on.
    </div>

    <div class="controls">
        <div class="input-group">
            <label>Array Size (m)</label>
            <input type="number" id="m-size" value="20" min="10" max="50">
        </div>
        <div class="input-group">
            <label>Hash Functions (k)</label>
            <input type="number" id="k-hashes" value="3" min="1" max="5">
        </div>
        <div class="input-group">
            <label>Data Input</label>
            <input type="text" id="data-input" placeholder="e.g. hello">
        </div>
        <div style="display:flex; gap:5px;">
            <button class="btn-add" onclick="addItem()">Add</button>
            <button class="btn-check" onclick="checkItem()">Check</button>
            <button class="btn-reset" onclick="resetFilter()">Reset</button>
        </div>
    </div>

    <div class="array-container">
        <div class="bit-labels">
            <span>Index 0</span>
            <span>Index <span id="max-index">19</span></span>
        </div>
        <div class="bit-grid" id="grid">
            </div>
    </div>

    <div class="status-box" id="log">
        <div class="log-item" style="color:#64748b">Logs will appear here...</div>
    </div>
</div>

<script>
    // State
    let m = 20;
    let k = 3;
    let bitArray = []; // Array of Set() objects. Each Set contains the strings that mapped here.

    // Init
    function init() {
        m = parseInt(document.getElementById('m-size').value);
        k = parseInt(document.getElementById('k-hashes').value);
        document.getElementById('max-index').innerText = m - 1;
        
        // Initialize array with empty Sets
        bitArray = Array.from({ length: m }, () => new Set());
        
        renderGrid();
        document.getElementById('log').innerHTML = '';
        log('System initialized.', 'add');
    }

    // A simple, consistent hash function simulator
    // In reality, you'd use Murmur3 or FNV. Here we simulate 'k' hashes by modifying a seed.
    function getHashes(str) {
        let hashes = [];
        for (let i = 0; i < k; i++) {
            let hash = 0;
            // A variant of djb2 hash algorithm, salted with 'i'
            let strWithSalt = str + "salt" + i; 
            for (let charIndex = 0; charIndex < strWithSalt.length; charIndex++) {
                let char = strWithSalt.charCodeAt(charIndex);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            // Map to 0...m-1
            hashes.push(Math.abs(hash) % m);
        }
        return hashes;
    }

    function addItem() {
        const input = document.getElementById('data-input').value;
        if (!input) return;

        const indices = getHashes(input);
        
        // Update State
        indices.forEach(idx => {
            bitArray[idx].add(input);
        });

        renderGrid();
        log(`Added "<b>${input}</b>". Mapped to indices: [${indices.join(', ')}]`, 'add');
        document.getElementById('data-input').value = '';
    }

    function checkItem() {
        const input = document.getElementById('data-input').value;
        if (!input) return;

        const indices = getHashes(input);
        
        // Check if all bits are non-empty
        // Note: In a real bloom filter, we just check 0/1. 
        // Here we check size > 0 to simulate the bit being set.
        const allBitsSet = indices.every(idx => bitArray[idx].size > 0);

        // Ground Truth Check (Did we actually add this specific string?)
        // We can do this because we are cheating and storing the sets in JS memory for this demo.
        // A real Bloom Filter CANNOT do this.
        let actuallyPresent = true;
        indices.forEach(idx => {
            if (!bitArray[idx].has(input)) actuallyPresent = false; // Strictly strictly speaking this logic is imperfect for ground truth but close enough for demo
        });
        
        // Correction: The only way to know ground truth in this sim is to check if ANY of the sets contain the string.
        // Actually, let's just maintain a global "added" list for ground truth verification.
        const globalAdded = new Set();
        bitArray.forEach(s => s.forEach(val => globalAdded.add(val)));
        const groundTruth = globalAdded.has(input);

        let resultMsg = "";
        if (allBitsSet) {
            if (groundTruth) {
                resultMsg = "Found (True Positive)";
            } else {
                resultMsg = "Found (FALSE POSITIVE!) - The bits were set by other items.";
            }
        } else {
            resultMsg = "Not Found (True Negative)";
        }

        log(`Checked "<b>${input}</b>". Indices: [${indices.join(', ')}] -> ${resultMsg}`, allBitsSet && !groundTruth ? 'error' : 'check');
    }

    function renderGrid() {
        const grid = document.getElementById('grid');
        grid.innerHTML = '';

        bitArray.forEach((set, i) => {
            const div = document.createElement('div');
            
            // Determine class
            let className = 'bit';
            if (set.size > 0) className += ' active';
            if (set.size > 1) className += ' collision'; // Multiple items mapped here

            div.className = className;
            div.innerText = i;
            
            // Tooltip data
            if (set.size > 0) {
                div.setAttribute('data-sources', `Sources: ${Array.from(set).join(', ')}`);
            } else {
                div.setAttribute('data-sources', 'Empty');
            }

            grid.appendChild(div);
        });
    }

    function log(msg, type) {
        const box = document.getElementById('log');
        const div = document.createElement('div');
        div.className = 'log-item';
        div.innerHTML = `<span class="tag ${type}">${type}</span> ${msg}`;
        box.prepend(div);
    }

    function resetFilter() {
        init();
    }

    // Start
    init();
    
    // Re-init on settings change
    document.getElementById('m-size').addEventListener('change', init);
    document.getElementById('k-hashes').addEventListener('change', init);

</script>

</body>
</html>
